<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="A chat parser for Final Fantasy XIV Online with the Advanced Combat Tracker (ACT) plugin." />
  <title>Nuu FFXIV ACT Plugin Chat Extractor</title>
  <!-- Nuu nuu!! -->
  <style type="text/css">
    :root {
      --color-light-hsl: hsl(0, 0%, 95%);
      --color-light-highlight-hsl: hsl(0, 0%, 90%);
      --color-dark-hsl: hsl(0, 0%, 5%);
      --color-popover-background: hsl(0, 0%, 10%);
      --color-dark-highlight-hsl: hsl(0, 0%, 15%);

      --color-width: 20px;
    }

    a {
      color: var(--color-light-hsl);
    }

    a:hover {
      color: var(--color-light-highlight-hsl);
    }

    .save-as {
      display: flex;
      align-items: center;
      font-weight: bold;
    }

    .filter {
      display: flex;
      gap: 0.5rem;

      /* This is to allow the popover to grow in width. */
      width: 100%;
      max-width: 300px;
    }

    .filter button {
      /* Easy way to make buttons not wrap on 2 lines! */
      white-space: nowrap;
    }

    #filter-popover {
      position: absolute;
      z-index: 10;
      max-width: 375px;
      padding: 0.5rem;
      background-color: var(--color-popover-background);
      border: 1px solid var(--color-light-hsl);
      box-shadow: 5px 5px 15px 5px hsla(0, 0%, 95%, 0.1);

      /* This should be set by javascript. */
      top: 30px;
    }

    .filter-types-toggle-container {
      display: flex;
      gap: 1rem;
      padding: 0.5rem 0;
      font-weight: bold;
      font-size: 0.85em;
    }

    .filter-types-toggle-container span {
      cursor: pointer;
    }

    .filter-types-toggle-container span:hover {
      text-decoration: underline;
      text-decoration-color: var(--color-light-hsl);
    }

    .hover-highlight {
      /* If you click the label it can get text selected. */
      user-select: none;
    }

    .hover-highlight:hover {
      background-color: var(--color-dark-highlight-hsl);
    }

    input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
    }
    input[type="color"]::-webkit-color-swatch {
      border: none;
    }
    input[type="color"]::-moz-color-swatch {
      border: none;
    }

    input[type=color] {
      width: var(--color-width);
      height: var(--color-width);
      border: 1px solid grey;
      cursor: pointer;
    }

    .filter-message-type-grid {
      display: grid;
      grid-template-columns: 1fr var(--color-width);
      grid-column-gap: 0.25em;
      margin-top: 0.25em;
    }

    .filter-message-type-grid input[type=color] {
      opacity: 0.2;
      transition: opacity 50ms ease-in;
    }

    .filter-message-type-grid:hover input[type=color] {
      opacity: 1;
    }

    .filter-message-type {
      cursor: pointer;
      display: block;
    }

    .filter-senders-container {
      display: flex;
      flex-direction: column;
    }

    .filter-sender {
      cursor: pointer;
    }

    .chat-settings-popover-container {
      margin-top: 0.5rem;
    }

    .chat-setting {

    }

    /* CSS below here will go to the generated output as well */
    /* Although it has to manually copied! */
    body {
      background-color: hsl(0, 0%, 5%);
      color: hsl(0, 0%, 95%);
      text-shadow: 1px 1px 0px rgba(64, 64, 64, 0.18);
      font-family: Arial;
    }

    #output {
      padding: 0.5rem;
    }

    .line {
      margin: 0.5rem 0;
    }

    .sender {
      font-weight: bold;
    }
  </style>
</head>
<body>
<section class="log-parser">
  <h1 style="margin: 5px 0">Select your log.</h1>
  <p style="margin: 5px 0">
    You can remove selected lines from the output by pressing delete or backspace.
  </p>
  <input id="loginput" type="file">
  <p id="error"></p>
</section>
<section class="parsed-log" style="display: none;">
  <div style="display: flex; gap: 0.5rem;">
    <div class="save-as">
      <a class="save-as-html">Save chat</a>
    </div>
    <div class="filter">
      <button class="filter-types">Filter Types</button>
      <button class="filter-senders">Filter Senders</button>
      <button class="sender-colours">Sender Colours</button>
      <button class="chat-settings">Chat settings</button>
      <div id="filter-popover" style="display: none;">
        <button class="popover-close-button">Close</button>
        <!-- The content is dynamically added by showFilterTypes, showFilterSenders, sender colours and chat settings -->
        <div class="filter-popover-content"></div>
      </div>
    </div>
  </div>
  <div id="output"></div>
</section>

<script type="text/javascript">
  // Auto calling function for its own scope.
  (function() {
    /**
     * Example data:
     * code: "001d"
     * message: "Nuusie gives Tiggy a big bonk."
     * sender: "Nuusie"
     * time: "20:49:41"
     * @typedef {{ code: string, message: string, sender: string, time: string, senderReference: Sender, id: string }} Line
     */

    /**
     * @typedef {{ code: string, class: string, name: string, color: string, [prependSender]: string, [suffixSender]: string, visible: boolean }} MessageType
     */

    /**
     * @typedef {{ name: string, count: number, visible: boolean, [customColor]: string, class: string }} Sender
     */

    /**
     * @typedef {{ codes: string[], name: string, regex: RegExp, [customMatcher]: Function, active: boolean, method: Function }} TextTransformer
     */

    /**
     * @typedef {{ text: string, transform: boolean }} TextMatchPart
     */

    /**
     * @typedef {{ opening: string, closing: string[], active: boolean }} QuotationRule
     */

    // Regexes from https://github.com/ErstonGreatman/ffxiv-act-chat-extractor
    // This one has 2 groups, name & realm.
    const nameRegex = /(?<name>[A-Z][a-z']+\s[A-Z][a-z']+)(?<realm>[A-Z][a-z]+)?/;
    // This one has 4 groups, time, code, sender and message
    const messageRegex = /00\|\d+-\d+-\d+T(?<time>\d+:\d+:\d+).+?\|(?<code>.+)\|.*?(?<sender>[A-Z][A-z']+? [A-z']+).*?\|(?<message>.+)\|[^]+/;

    let hasAddedCSS = false;
    let isSaveAsDirty = false;
    let alwaysUpdateBlobs = false;

    /**
     * @type {Line[]}
     */
    let currentParsedLines = [];

    // Also copied & modified from https://github.com/ErstonGreatman/ffxiv-act-chat-extractor
    /**
     * @type {Object.<string, MessageType>}
     */
    const messageTypes = {
      '000a': { code: '000a', class: 'say', name: 'Say', color: '#ffffff', visible: true },
      '000b': { code: '000b', class: 'shout', name: 'Shout', color: '#eb9234', visible: true },
      '000e': { code: '000e', class: 'party', name: 'Party', color: '#1ecce3', visible: true },
      '000f': { code: '000f', class: 'alliance', name: 'Alliance', color: '#eb9234', visible: true },
      '0018': { code: '0018', class: 'free', name: 'Free Company', color: '#54b068', visible: true },
      // 001c and 001d seems to be emotes.
      '001c': { code: '001c', class: 'emote-custom', name: 'Custom Emote', color: '#df7423', visible: true },
      '001d': { code: '001d', class: 'emote', name: 'Emote', color: '#df7423', visible: true },
      '001e': { code: '001e', class: 'yell', name: 'Yell', color: '#c9c722', visible: true },

      // Tell from you to someone!
      '000c': { code: '000c', class: 'tell-to', name: 'Tell To', color: '#d439cc', prependSender: 'To ', suffixSender: '', visible: true },
      // Tell from someone to you.
      '000d': { code: '000d', class: 'tell-from', name: 'Tell From', color: '#d439cc', prependSender: 'From ', suffixSender: '', visible: true },

      '0039': { code: '0039', class: 'whisper', name: 'Whisper', color: '#d439cc', visible: true },
      '0010': { code: '0010', class: 'linkshell-1', name: 'Linkshell 1', color: '#31b56a', visible: true },
      '0011': { code: '0011', class: 'linkshell-2', name: 'Linkshell 2', color: '#2a8c9c', visible: true },
      '0012': { code: '0012', class: 'linkshell-3', name: 'Linkshell 3', color: '#296196', visible: true },
      '0013': { code: '0013', class: 'linkshell-4', name: 'Linkshell 4', color: '#2d509c', visible: true },
      '0014': { code: '0014', class: 'linkshell-5', name: 'Linkshell 5', color: '#5959b1', visible: true },
      '0015': { code: '0015', class: 'linkshell-6', name: 'Linkshell 6', color: '#7159b1', visible: true },
      '0016': { code: '0016', class: 'linkshell-7', name: 'Linkshell 7', color: '#7b51af', visible: true },
      '0017': { code: '0017', class: 'linkshell-8', name: 'Linkshell 8', color: '#9551af', visible: true },

      // Other codes:
      /*
        0044: System messages, eg: "The limited-time event “Leap of Faith” is now underway in Round Square. All guests are encouraged to participate!"
       */
    };

    /**
     * @type {MessageType[]}
     */
    const messageTypesAsArray = Object.values(messageTypes);

    /**
     * @type {Sender[]}
     */
    const customSenderColours = [];

    /**
     * @type {Sender[]}
     */
    const senders = [];

    // List of quotation rules: https://en.wikipedia.org/wiki/Quotation_mark
    // Total unique characters: `'"‚„‘“’«‹›»〈《「『”〉》」』
    /**
     * @type {QuotationRule[]}
     */
    const quotationRules = [
      { opening: '`', closing: ['`'], active: true, },
      { opening: '#039;', closing: ['#039;'], active: false, },
      { opening: '&quot;', closing: ['&quot;'], active: true, },
      { opening: '‚', closing: ['‘', '’'], active: true, },
      { opening: '„', closing: ['“'], active: true, },
      { opening: '‘', closing: ['’'], active: true, },
      { opening: '“', closing: ['”'], active: true, },
      { opening: '’', closing: ['’'], active: true, },
      { opening: '‹', closing: ['›'], active: true, },
      { opening: '〈', closing: ['〉'], active: true, },
      { opening: '«', closing: ['»'], active: true, },
      { opening: '《', closing: ['》'], active: true, },
      { opening: '›', closing: ['‹'], active: true, },
      { opening: '»', closing: ['«', '»'], active: true, },
      { opening: '「', closing: ['」'], active: true, },
      { opening: '『', closing: ['』'], active: true, },
    ];

    /**
     * @type {TextTransformer[]}
     */
    const transformTextRules = [
      { codes: ['001c', '001d'], name: 'Always show emote colour', regex: /.*/gm, active: true, method: transformTextToEmoteText },
      { codes: ['001c', '001d'], name: 'Quotes in emotes as say', customMatcher: getQuotationMatches, active: true, method: transformQuotesToSayOrCustomSender },
      { codes: ['*'], name: 'Asterisks as emote', regex: /\*[^\*]+\*/gm, active: true, method: transformAsterisksAsEmote },
      { codes: ['*'], name: '( Out of character )', customMatcher: getOutOfCharacterMatches, regex: /\([^\)]+\)/, active: true, method: transformOutOfCharacter },
      // { codes: ['*'], excludeCodes: ['001c', '001d'], name: 'Treat non-quoted text as emote', regex: '', active: false },
      // { codes: ['001c', '001d'], name: 'Treat quotes in emote as say', regex: '', active: false },
    ];

    let errorElement;
    /**
     * @type {HTMLElement}
     */
    let filterPopoverElement;
    const popoverOpeners = {
      filterTypes: '.filter-types',
      filterSenders: '.filter-senders',
      senderColours: '.sender-colours',
      chatSettings: '.chat-settings',
    }
    let lastPopoverOpener = '';
    let logFilename = '';
    let existingObjectURLs = [];

    window.addEventListener('DOMContentLoaded', () => {
      const logInput = document.getElementById('loginput');
      errorElement = document.getElementById('error');

      const filterRootElement = document.querySelector('.filter');

      const filterTypesElement = filterRootElement.querySelector('.filter-types');
      filterTypesElement.addEventListener('click', showFilterTypes);

      const filterSendersElement = filterRootElement.querySelector('.filter-senders');
      filterSendersElement.addEventListener('click', showFilterSenders);

      const senderColoursElement = filterRootElement.querySelector('.sender-colours');
      senderColoursElement.addEventListener('click', showSenderColours);

      const chatSettingsElement = filterRootElement.querySelector('.chat-settings');
      chatSettingsElement.addEventListener('click', showChatSettings);

      filterPopoverElement = document.getElementById('filter-popover');
      const closeButtonElement = filterPopoverElement.querySelector('.popover-close-button');
      closeButtonElement.addEventListener('click', closeFilterPopover);

      logInput.addEventListener('change', handleLogUpload, false);

      document.addEventListener('click', (event) => {
        if (lastPopoverOpener === '') {
          return;
        }

        let closePopup = true;
        let target = event.target;
        while (target) {
          if (target === filterRootElement) {
            closePopup = false;
            break;
          }

          target = target.parentElement;
        }

        if (closePopup) {
          closeFilterPopover();
        }
      });

      document.addEventListener('keyup', (event) => tryRemoveSelectedText(event));

      // If you don't have hover capabilities we need to always update the blobs.
      // The chance of someone using this from a touchscreen only is rather low though but you never know!
      // I think this can just be a click event but maybe it doesn't work in all browsers as we're updating the URL on click.
      // Plus the URL doesn't exist then.
      if (window.matchMedia('(any-hover: none)').matches) {
        alwaysUpdateBlobs = true;
      } else {
        const saveAsHTMLAnchor = document.querySelector('.save-as-html');
        saveAsHTMLAnchor.addEventListener('pointerover', () => {
          onMouseOverUpdateSaveAsbuttons();
        });
      }
    });

    // Oh dear, having to do this again because 1 single file ^.^
    // *******************************************
    // FILTER methods
    // ******************************************
    function showFilterTypes() {
      if (lastPopoverOpener === popoverOpeners.filterTypes) {
        closeFilterPopover();
        return;
      }

      const contentElement = showFilterPopoverAndGetContentElement(popoverOpeners.filterTypes);
      const fragment = document.createDocumentFragment();

      addTypesToggle(fragment, messageTypesAsArray, '.filter-message-type input[type=checkbox]');

      for (const messageType of messageTypesAsArray) {
        const gridContainer = document.createElement('div');
        gridContainer.className = 'filter-message-type-grid hover-highlight';

        const messageTypeElement = document.createElement('label');
        messageTypeElement.className = `filter-message-type ${messageType.class}`;

        messageTypeElement.innerHTML = `
<input id="${messageType.code}" type="checkbox">
<span>${messageType.name}</span>
        `;

        const inputElement = messageTypeElement.querySelector('input');
        inputElement.checked = messageType.visible;

        // This will happen twice if you click on the <span> because once for the label and once for the checkbox.
        messageTypeElement.onclick = () => {
          messageType.visible = inputElement.checked;
          generateOutput(currentParsedLines);
        }

        const colorChanger = document.createElement('input');
        colorChanger.type = 'color';
        colorChanger.value = messageType.color;
        colorChanger._oldValue = messageType.color;
        colorChanger.addEventListener('input', () => {
          if (colorChanger.value === colorChanger._oldValue) {
            return;
          }

          colorChanger._oldValue = colorChanger.value;
          messageType.color = colorChanger.value;
          updateColours();
        });

        gridContainer.appendChild(messageTypeElement);
        gridContainer.appendChild(colorChanger);

        fragment.appendChild(gridContainer);
      }

      contentElement.appendChild(fragment);
    }

    function showFilterSenders() {
      if (lastPopoverOpener === popoverOpeners.filterSenders) {
        closeFilterPopover();
        return;
      }

      const contentElement = showFilterPopoverAndGetContentElement(popoverOpeners.filterSenders);
      const fragment = document.createDocumentFragment();

      const sortedSenders = getSortedSenders();

      addTypesToggle(fragment, sortedSenders, 'input[type=checkbox]');

      const sendersContainerElement = document.createElement("div");
      sendersContainerElement.className = 'filter-senders-container';

      for (const sender of sortedSenders) {
        const senderElement = document.createElement('label');
        senderElement.className = `filter-sender hover-highlight`;

        senderElement.innerHTML = `
<input type="checkbox" class="hover-highlight">
<span>${sender.name}</span>
<span class="sender-count">${sender.count}</span>
        `;

        const inputElement = senderElement.querySelector('input');
        inputElement.checked = sender.visible;

        senderElement.onclick = () => {
          sender.visible = inputElement.checked;
          generateOutput(currentParsedLines);
        }

        sendersContainerElement.appendChild(senderElement);
      }

      fragment.appendChild(sendersContainerElement);

      contentElement.appendChild(fragment);
    }

    /**
     * @param {DocumentFragment} fragment
     * @param {{ visible: boolean }[]}
     */
    function addTypesToggle(fragment, items, query) {
      const toggleContainer = document.createElement('div');
      toggleContainer.className = 'filter-types-toggle-container';

      const allToggle = document.createElement('span');
      allToggle.innerText = 'All';
      allToggle.onclick = () => {
        setVisibility(true);
      }

      const noneToggle = document.createElement('span');
      noneToggle.innerText = 'None';
      noneToggle.onclick = () => {
        setVisibility(false);
      }

      toggleContainer.appendChild(allToggle);
      toggleContainer.appendChild(noneToggle);
      fragment.appendChild(toggleContainer);

      function setVisibility(visibility) {
        const popoverElement = document.getElementById('filter-popover');
        for (const item of items) {
          item.visible = visibility;
        }

        /**
         * @type {HTMLInputElement[]}
         */
        const inputElements = popoverElement.querySelectorAll(query);
        for (const element of inputElements) {
          element.checked = visibility;
        }
        generateOutput(currentParsedLines);
      }
    }

    function showFilterPopoverAndGetContentElement(opener) {
      clearFilterPopover();
      filterPopoverElement.style.display = '';
      lastPopoverOpener = opener;
      const popoverContent = filterPopoverElement.querySelector('.filter-popover-content');

      /**
       * @type {HTMLElement}
       */
      const openerElement = document.querySelector(opener);
      if (!openerElement) {
        return popoverContent;
      }

      const filterRootElement = document.querySelector('.filter');
      const bounds = openerElement.getBoundingClientRect();
      const filterBounds = filterRootElement.getBoundingClientRect();
      filterPopoverElement.style.left = `${bounds.left}px`;
      filterPopoverElement.style.top = `${filterBounds.bottom + 5}px`;

      return popoverContent;
    }

    function closeFilterPopover() {
      lastPopoverOpener = '';
      const filterPopoverElement = document.getElementById('filter-popover');
      filterPopoverElement.style.display = 'none';

      const contentElement = filterPopoverElement.querySelector('.filter-popover-content');
      while (contentElement.firstChild) {
        contentElement.removeChild(contentElement.firstChild);
      }
    }

    function clearFilterPopover() {
      const contentElement = filterPopoverElement.querySelector('.filter-popover-content');

      while (contentElement.firstChild) {
        contentElement.removeChild(contentElement.firstChild);
      }
    }

    function getSortedSenders() {
      const sortedSenders = [...senders];
      sortedSenders.sort((a, b) => {
        return b.count - a.count;
      });
      return sortedSenders;
    }

    function showSenderColours() {
      if (lastPopoverOpener === popoverOpeners.senderColours) {
        closeFilterPopover();
        return;
      }

      const contentElement = showFilterPopoverAndGetContentElement(popoverOpeners.senderColours);
      const fragment = document.createDocumentFragment();
      const sortedSenders = getSortedSenders();

      const descriptionElement = document.createElement('p');
      descriptionElement.innerText = 'Applies a custom colour for the sender if checked.'
      fragment.appendChild(descriptionElement);

      const toggleContainer = document.createElement('div');
      toggleContainer.className = 'filter-types-toggle-container';
      const noneToggle = document.createElement('span');
      noneToggle.innerText = 'None';
      noneToggle.onclick = () => {
        customSenderColours.splice(0, customSenderColours.length);
        const checkboxes = contentElement.querySelectorAll('input[type=checkbox]');
        let hasChanges = false;
        for (const checkbox of checkboxes) {
          if (checkbox.checked) {
            hasChanges = true;
          }
          checkbox.checked = false;
        }

        if (hasChanges) {
          generateOutput(currentParsedLines);
        }

        updateColours();
      }

      toggleContainer.appendChild(noneToggle);
      fragment.appendChild(toggleContainer);

      for (const sender of sortedSenders) {
        const senderColourElement = document.createElement('div');
        senderColourElement.className = 'filter-message-type-grid hover-highlight';
        senderColourElement.innerHTML = `
<label>
  <input type="checkbox" >
  <span>${sender.name}</span>
</label>
<input type="color">
        `;

        const checkboxElement = senderColourElement.querySelector('input[type=checkbox]');
        checkboxElement.checked = !!customSenderColours.find(s => s === sender);

        checkboxElement.addEventListener('click', () => {
          if (!checkboxElement.checked) {
            const index = customSenderColours.indexOf(sender);
            if (index !== -1) {
              customSenderColours.splice(index, 1);
            }
          } else {
            customSenderColours.push(sender);
          }

          updateColours();
        });

        // This seems to be fine even with the None click that only 1 event happens.
        // Otherwise we probably need a debounce.
        checkboxElement.addEventListener('change', () => {
          requestAnimationFrame(() => {
            generateOutput(currentParsedLines);
          });
        });

        const colorElement = senderColourElement.querySelector('input[type=color]');
        colorElement.value = sender.customColor;
        colorElement.addEventListener('input', () => {
          sender.customColor = colorElement.value;
          if (!checkboxElement.checked) {
            checkboxElement.click();
          }

          updateColours();
        });

        fragment.appendChild(senderColourElement);
      }
      contentElement.appendChild(fragment);
    }

    // ***********************************
    // Chat settings methods
    // ***********************************
    function showChatSettings() {
      if (lastPopoverOpener === popoverOpeners.chatSettings) {
        closeFilterPopover();
        return;
      }
      const contentElement = showFilterPopoverAndGetContentElement(popoverOpeners.chatSettings);
      const fragment = document.createDocumentFragment();

      const settingsContainerElement = document.createElement('div');
      settingsContainerElement.className = 'chat-settings-popover-container';

      addTransformRulesToChatSettings(settingsContainerElement);

      fragment.appendChild(settingsContainerElement);

      contentElement.appendChild(fragment);
    }

    /**
     * @param {HTMLElement} settingsContainerElement
     */
    function addTransformRulesToChatSettings(settingsContainerElement) {
      for (const rule of transformTextRules) {
        const ruleElement = document.createElement('div');
        ruleElement.className = 'chat-setting hover-highlight';

        ruleElement.innerHTML = `
<label>
  <input type="checkbox">
  <span>${rule.name}</span>
</label>
        `;

        const input = ruleElement.querySelector('input');
        input.checked = rule.active;

        const label = ruleElement.querySelector('label');
        label.addEventListener('click', () => {
          rule.active = input.checked;
          generateOutput(currentParsedLines);
        });

        settingsContainerElement.appendChild(ruleElement);
      }
    }

    // ***********************************
    // Transform Text methods
    // called inside tryTransformText()
    // ***********************************

    /**
     * @param {TextMatchPart[]} textParts
     * @param {Line} line
     */
    function transformTextToEmoteText(textParts, line) {
      let text = '';
      for (const part of textParts) {
        if (!part.transform) {
          text += part.text;
        }
        const className = messageTypes['001c'].class;
        text += `<span class="${className}">${part.text}</span>`;
      }

      return text;
    }

    /**
     * @param {TextMatchPart[]} textParts
     * @param {Line} line
     */
    function transformAsterisksAsEmote(textParts, line) {
      let text = '';
      for (const part of textParts) {
        if (!part.transform) {
          text += part.text;
        } else {
          const className = messageTypes['001c'].class;
          text += `<span class="${className}">${part.text}</span>`;
        }
      }

      return text;
    }

    /**
     * @param {TextMatchPart[]} textParts
     * @param {Line} line
     */
    function transformQuotesToSayOrCustomSender(textParts, line) {
      let text = '';
      for (const part of textParts) {
        if (!part.transform) {
          text += part.text;
        } else {
          let className;
          if (customSenderColours.indexOf(line.senderReference) !== -1) {
            className = line.senderReference.class;
          } else {
            className = messageTypes['000a'].class;
          }
          text += `<span class="${className}">${part.text}</span>`;
        }
      }

      return text;
    }

    /**
     * @param {TextMatchPart[]} textParts
     * @param {Line} line
     */
    function transformOutOfCharacter(textParts, line) {
      let text = '';
      for (const part of textParts) {
        if (!part.transform) {
          text += part.text;
        } else {
          text += `<span style="opacity: 0.8">${part.text}</span>`;
        }
      }

      return text;
    }

    // *************************************
    // Transformer Matching methods
    // *************************************
    /**
     * @param {string} text
     * @param {TextTransformer} transformer
     * @returns {RegExpMatchArray[]}
     */
    function getQuotationMatches(text, transformer) {
      let matches = [];
      let currentIndex = 0;

      while (currentIndex < text.length) {
        const nextIndices = getNextQuotationIndices(text, currentIndex);
        if (!nextIndices) {
          break;
        }

        const match = [text.substr(nextIndices.openingIndex, nextIndices.closingIndex - nextIndices.openingIndex)];
        match.index = nextIndices.openingIndex;
        matches.push(match);
        currentIndex = nextIndices.closingIndex;
      }

      return matches;
    }

    /**
     * @returns {{ openingIndex: number, closingIndex: number } | undefined}
     */
    function getNextQuotationIndices(text, currentIndex) {
      const quotations = [];

      for (const quotationRule of quotationRules) {
        if (!quotationRule.active) {
          continue;
        }

        const openingIndex = text.indexOf(quotationRule.opening, currentIndex);
        if (openingIndex === -1) {
          continue;
        }

        for (const closingCharacter of quotationRule.closing) {
          const closingIndex = text.indexOf(closingCharacter, openingIndex + 1);
          if (closingIndex !== -1) {
            quotations.push({
              openingIndex,
              closingIndex: closingIndex + closingCharacter.length,
            });
          }
        }
      }

      if (!quotations.length) {
        return undefined;
      }

      quotations.sort((a, b) => a.openingIndex - b.openingIndex);
      return quotations[0];
    }

    /**
     * @param {string} text
     * @param {TextTransformer} transformer
     * @returns {RegExpMatchArray[]}
     */
    function getOutOfCharacterMatches(text, transformer) {
      let matches = [];

      const firstIndex = text.indexOf('(');
      if (firstIndex === -1 || text.indexOf(')', firstIndex) === -1) {
        return matches;
      }
      if (!transformer.regex.test(text)) {
        return matches;
      }

      let lookingForOpening = true;
      let lookingForClosing = false;
      let currentOpenParenthesisCount = 0;
      let currentClosedParenthesisCount = 0;

      let currentOpeningStart = -1;

      for (let i = firstIndex; i < text.length; i++) {
        const char = text[i];

        if (lookingForOpening && char === '(') {
          currentOpenParenthesisCount++;
        } else if (lookingForClosing && char === ')') {
          currentClosedParenthesisCount++;

          if (currentClosedParenthesisCount === currentOpenParenthesisCount) {
            lookingForOpening = true;
            lookingForClosing = false;
            currentOpenParenthesisCount = 0;

            const length = i - currentOpeningStart + 1;
            const match = [text.substr(currentOpeningStart, length)];
            match.index = currentOpeningStart;

            matches.push(match);
          }
        } else {
          currentClosedParenthesisCount = 0;
          if (lookingForOpening && currentOpenParenthesisCount > 0) {
            currentOpeningStart = i - currentOpenParenthesisCount;
            lookingForOpening = false;
            lookingForClosing = true;
          }
        }
      }
      return matches;
    }


    // ***********************************
    // Parsing methods
    // ***********************************

    /**
     * @param {Event} event
     */
    function handleLogUpload(event) {
      if (!event.target.files?.length) {
        return;
      }

      if (!hasAddedCSS) {
        addCSS();
      }

      const file = event.target.files[0];
      logFilename = file.name;
      const fr = new FileReader();
      fr.onload = () => {
        parseLog(fr.result || '');
      }
      fr.onerror = () => {
        errorElement.innerHTML = `Failed to read file ${logFilename}`;
        const outputElement = document.getElementById('output');
        while (outputElement.firstChild) {
          outputElement.removeChild(outputElement.firstChild);
        }
      }

      fr.readAsText(file);
    }

    /**
     * @param {string} logText
     */
    function parseLog(logText) {
      if (!logText) {
        return;
      }

      // Reset variables and close potential popover.
      closeFilterPopover();
      customSenderColours.splice(0, customSenderColours.length);
      clearObjectURLs();

      currentParsedLines = getLines(logText);

      addAllSenders(currentParsedLines);
      generateOutput(currentParsedLines);
    }

    /**
     * @param {string} text
     * @returns {Line[]}
     */
    function getLines(text) {
      const lines = text.split('\n');
      const result = [];
      // We group all the errors so we only do 1 single console.log()
      const errors = {};

      let index = 0;
      for (const line of lines) {
        const match = line.match(messageRegex);
        if (!match || !match.groups) {
          continue;
        }

        const message = escapeHTML(match.groups['message']);
        const code = match.groups['code'];
        let item = {
          code,
          message,
          sender: match.groups['sender'],
          time: match.groups['time'],
        };

        if (!messageTypes[code]) {
          let error = errors[code];
          if (!errors[code]) {
            error = {
              code,
              lines: [],
            };
            errors[code] = error
          }
          error.lines.push(item);
          continue;
        }

        item.id = index.toString();
        index++;
        result.push(item);
      }

      if (Object.values(errors).length > 0) {
        console.log('Lines without codes:', errors);
      }

      return result;
    }

    // Source: https://stackoverflow.com/a/6234804/2437350
    function escapeHTML(text) {
      return text.replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    /**
     * @param {Line[]} lines
     */
    function addAllSenders(lines) {
      senders.splice(0, senders.length);

      for (const line of lines) {
        let sender = senders.find((s) => s.name === line.sender);
        if (!sender) {
          const senderClass = getSenderClass(line.sender);
          sender = {
            name: line.sender,
            count: 0,
            visible: true,
            class: senderClass,
          };
          senders.push(sender);
        }

        line.senderReference = sender;
        sender.count++;
      }
    }

    /**
     * @param {string} sender
     */
    function getSenderClass(sender) {
      return 's-' + sender.toLowerCase().split(' ').join('-');
    }

    // *********************************
    // Output methods
    // *********************************
    /**
     * @param {Line[]} lines
     */
    function generateOutput(lines) {
      const parsedLogElement = document.querySelector('.parsed-log');

      const filteredLines = lines.filter(line => {
        if (!messageTypes[line.code] || !messageTypes[line.code].visible) {
          return false;
        }

        if (!line.senderReference?.visible) {
          return false;
        }

        return true;
      });

      const outputElement = document.getElementById('output');
      const fragment = document.createDocumentFragment();
      for (const line of filteredLines) {
        const lineElement = createLineElement(line);
        fragment.appendChild(lineElement);
      }

      // Finally add the fragment.
      while (outputElement.firstChild) {
        outputElement.removeChild(outputElement.firstChild);
      }
      outputElement.appendChild(fragment);
      parsedLogElement.style.display = '';

      dirtySaveAsAndTryUpdate();
    }

    /**
     * Since we aren't using any framework because this is a static html page - although something like Svelte could have been nice if it can be run without a localhost server.
     * @param {Line} line
     */
    function createLineElement(line) {
      const codeDetail = messageTypes[line.code];
      const codeClass = codeDetail && codeDetail.class;
      const element = document.createElement('p');
      const prependSender = codeDetail && codeDetail.prependSender || '';
      const activeTransformers = transformTextRules.filter(r => r.active);

      const message = createLineMessage(line, activeTransformers);

      element.className = `line ${codeClass} ${line.senderReference.class}`;
      element.dataset['id'] = line.id;
      element.innerHTML = `<span class="time">[${line.time}]</span> <span class="sender">${prependSender}${line.sender}:</span> <span class="message">${message}</span>`;
      return element;
    }

    /**
     * Create the CSS by adding the colours for the message types and custom senders.
     */
    function createCSS() {
      let css = '';
      for (const detail of messageTypesAsArray) {
        css += `
.${detail.class} { color: ${detail.color}; }
        `;
      }

      for (const sender of customSenderColours) {
        css += `
.${sender.class} { color: ${sender.customColor}; }
        `
      }

      return css;
    }

    /**
     * @param {Line} line
     * @param {TextTransformer[]} activeTransformers
     */
    function createLineMessage(line, activeTransformers) {
      if (!activeTransformers?.length) {
        return line.message;
      }

      let message = line.message;
      for (const transformer of activeTransformers) {
        message = tryTransformText(message, transformer, line);
      }

      return message;
    }

    /**
     * @param {string} text
     * @param {TextTransformer} transformer
     * @param {Line} line
     */
    function tryTransformText(text, transformer, line) {
      let canTransform = false;
      for (const code of transformer.codes) {
        if (code === '*') {
          canTransform = true;
          break;
        }

        if (code === line.code) {
          canTransform = true;
          break;
        }
      }

      if (!canTransform) {
        return text;
      }

      const matchedText = getMatchedText(text, transformer);
      if (!matchedText?.length) {
        return text;
      }

      return transformer.method(matchedText, line);
    }

    /**
     * @param {string} text
     * @param {TextTransformer} transformer
     * @returns {TextMatchPart[] | undefined}
     */
    function getMatchedText(text, transformer) {
      let matches;

      if (transformer.customMatcher) {
        matches = transformer.customMatcher(text, transformer);
      } else if (transformer.regex) {
        matches = [...text.matchAll(transformer.regex)];
        matches = matches.filter(m => m[0]);
      }

      if (!matches?.length) {
        return undefined;
      }

      let result = [];
      let currentIndex = 0;
      for (const match of matches) {
        const before = text.substr(currentIndex, match.index - currentIndex);
        if (before.length) {
          result.push({
            text: before,
            transform: false,
          });
        }

        result.push({
          text: match[0],
          transform: true,
        });

        currentIndex = match.index + match[0].length;
      }

      if (currentIndex < text.length) {
        result.push({
          text: text.substr(currentIndex),
          transform: false,
        });
      }
      return result;
    }

    function addCSS() {
      const styleElement = document.createElement("style");
      const css = createCSS();

      styleElement.appendChild(document.createTextNode(css));
      document.head.appendChild(styleElement);

      hasAddedCSS = true;
    }

    function updateColours() {
      const style = document.styleSheets[1];

      while (style.cssRules.length) {
        style.removeRule(0);
      }
      let index = 0;

      for (const messageType of messageTypesAsArray) {
        const css = `.${messageType.class} { color: ${messageType.color}; }`;
        style.insertRule(css, index++);
      }

      for (const sender of customSenderColours) {
        const css = `.${sender.class} { color: ${sender.customColor} }`;
        style.insertRule(css, index++);
      }

      dirtySaveAsAndTryUpdate();
    }

    // *********************************
    // Save as methods
    // *********************************
    function clearObjectURLs() {
      // To reduce memory leaks.
      for (const existingUrl of existingObjectURLs) {
        window.URL.revokeObjectURL(existingUrl);
      }
      existingObjectURLs = [];
    }

    function onMouseOverUpdateSaveAsbuttons() {
      if (!isSaveAsDirty) {
        return;
      }

      generateSaveAsButtons();
    }

    function dirtySaveAsAndTryUpdate() {
      isSaveAsDirty = true;

      if (alwaysUpdateBlobs) {
        generateSaveAsButtons();
      }
    }

    function generateSaveAsButtons() {
      isSaveAsDirty = false;
      clearObjectURLs();
      generateSaveAsHTML();
    }

    function generateSaveAsHTML() {
      const outputElement = document.getElementById('output');
      const saveAsHTMLAnchor = document.querySelector('.save-as-html');
      const output = getHTMLOutput(logFilename, outputElement.innerHTML);
      const blob = new Blob([output]);
      const url = window.URL.createObjectURL(blob);
      saveAsHTMLAnchor.href = url;
      saveAsHTMLAnchor.download = logFilename + '.html';
      existingObjectURLs.push(url);
    }

    function getHTMLOutput(filename, content) {
      const css = createCSS();

      const output = `
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>${filename}</title>
  <style>
    body {
      background-color: hsl(0, 0%, 5%);
      color: hsl(0, 0%, 95%);
      text-shadow: 1px 1px 0px rgba(0, 0, 0, 0.18);
      font-family: Arial;
    }

    #output {
      padding: 0.5rem;
    }

    .line {
      margin: 0.5rem 0;
    }

    .sender {
      font-weight: bold;
    }

    ${css}
  </style>
</head>
<body>
  <div id="output">
    ${content}
  </div>
</body>
</html>
      `;

      return output;
    }

    // ***************************
    // Misc. Functionality
    // ***************************

    /**
     *
     * @param {KeyboardEvent} event
     */
    function tryRemoveSelectedText(event) {
      if (event.key !== 'Delete' && event.key !== 'Backspace') {
        return;
      }

      const selection = document.getSelection();
      if (!selection.rangeCount) {
        return;
      }

      const range = selection.getRangeAt(0);
      const outputElement = document.getElementById('output');
      const errorElement = document.getElementById('error');
      if (range.commonAncestorContainer !== outputElement && !outputElement.contains(range.commonAncestorContainer)) {
        errorElement.innerText = `Can't remove selected text because it's not only the output.`;
        // This is a horrible solution but better than nothing.
        setTimeout(() => {
          errorElement.innerText = '';
        }, 5000)
        return;
      }

      errorElement.innerText = '';
      const focusLine = getLineElementFromSelectionNode(selection.focusNode);
      const anchorLine = getLineElementFromSelectionNode(selection.anchorNode);

      if (!focusLine || !anchorLine) {
        return;
      }

      let focusLineNumber = parseInt(focusLine.dataset['id'], 10);
      let anchorLineNumber = parseInt(anchorLine.dataset['id'], 10);

      if (isNaN(focusLineNumber) || isNaN(anchorLineNumber)) {
        return;
      }

      // focus or anchor node can be from either direction depending if you drag left or right with the selection.
      const from = focusLineNumber <= anchorLineNumber ? focusLine : anchorLine;
      const to = focusLineNumber >= anchorLineNumber ? focusLine : anchorLine;
      let removeLines = false;

      // There can be hidden lines so we need to get them index by index.
      for (let i = outputElement.children.length - 1; i >= 0; i--) {
        const child = outputElement.children[i];
        if (!child.classList.contains('line')) {
          continue;
        }

        if (child === to) {
          removeLines = true;
        }

        if (removeLines) {
          const id = child.dataset['id'];
          const index = currentParsedLines.findIndex(l => l.id === id);
          currentParsedLines.splice(index, 1);
          outputElement.removeChild(child);
        }

        if (child === from) {
          break;
        }
      }

      generateOutput(currentParsedLines);
    }

    function getLineElementFromSelectionNode(node) {
      while (node.parentNode) {
        if (node.classList?.contains('line')) {
          return node;
        }

        node = node.parentNode;
      }

      return undefined;
    }

  })();
</script>
</body>
</html>
